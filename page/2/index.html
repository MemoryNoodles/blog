<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="前端,李永平,博客">
<meta name="keywords" content="前端,html5,javascript,react,react-native,css">
<meta property="og:type" content="website">
<meta property="og:title" content="李永平的博客">
<meta property="og:url" content="https://MemoryNoodles.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="李永平的博客">
<meta property="og:description" content="前端,李永平,博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李永平的博客">
<meta name="twitter:description" content="前端,李永平,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://MemoryNoodles.github.io/blog/page/2/">





  <title> 李永平的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">李永平的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">你今天比昨天更博学了吗？</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2019/04/25/VSCode开发react-native/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/25/VSCode开发react-native/" itemprop="url">
                  VS Code开发react-native
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T20:40:23+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2019/04/25/VSCode开发react-native/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/25/VSCode开发react-native/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>react-native官网推荐下载安装使用的Android Studio，没用过，这里也妄加猜测。只是我下载来看了一下，不能装插件、没颜色区分、各种难看。当时就下定决心说，我不要用这种IDE,于是GOOGLE了vs code开发react-native相关的文章。皇天不负有心人，终于让我找到了方法，在这里写下来，希望对你有用</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>还没写</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2019/04/24/react-native搭建环境的坑/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/24/react-native搭建环境的坑/" itemprop="url">
                  react-native搭建环境的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T20:03:42+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2019/04/24/react-native搭建环境的坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/24/react-native搭建环境的坑/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>react-native是众所周知的性能比较好，但是坑也是走一步5个坑这种，今天有机会闲下来，就把搭建环境遇到的坑说一下。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>版本问题:使用react-native的最新版0.59.5的有问题，改为了0.57.5，以为这就好了吗？远没有；还要在android文件夹下新建local.properties文件，在文件内写入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk.dir=C\:\\Users\\lyp\\AppData\\Local\\Android\\sdk</span><br></pre></td></tr></table></figure></p>
<p>同时新建gradle.properties文件，在文件内写入，注意如果为java设置了环境变量那就不用做下面这一步了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.java.home=D:\\Program Files\\JAVA\\jdk1.8_201</span><br></pre></td></tr></table></figure></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>前面的步骤完了，这时你可以去吃饭了（呵呵）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2019/04/01/puling-node/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/01/puling-node/" itemprop="url">
                  《深入浅出Node.js》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T07:10:09+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2019/04/01/puling-node/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/01/puling-node/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你想要深入学习Node，那你不能错过《深入浅出Node.js》这本书，它从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。在读这本书的过程中我收获颇多，并用思维导图的方式记录下来，方便自己后期温故。如果你刚好没有读过，可以当做度这本书的预习阅读，相信你也会有所收获（思维导图图片可能有点小，记得点开看）</p>
<h3 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章　Node简介"></a>第1章　Node简介</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf797e5ca946?w=1087&amp;h=694&amp;f=jpeg&amp;s=112844" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7beac28eea?w=1088&amp;h=445&amp;f=jpeg&amp;s=39820" alt></p>
<h3 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章　模块机制"></a>第2章　模块机制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7f53fdae09?w=1180&amp;h=393&amp;f=jpeg&amp;s=36439" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf823d7036bf?w=1180&amp;h=734&amp;f=jpeg&amp;s=141761" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf850d0a355e?w=1183&amp;h=745&amp;f=jpeg&amp;s=164967" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf8757804e03?w=1180&amp;h=527&amp;f=jpeg&amp;s=80154" alt><br>CommonJS提出的规范均十分简单,但是现实意义却十分强大。Node通过模块规范,组织了 自身的原生模块,弥补JavaScript弱结构性的问题,形成了稳定的结构,并向外提供服务。NPM 通过对包规范的支持,有效地组织了第三方模块,这使得项目开发中的依赖问题得到很好的解决, 并有效提供了分享和传播的平台,借助第三方开源力量,使得Node第三方模块的发展速度前所未 有,这对于其他后端JavaScript语言实现而言是从未有过的。从一定的角度上讲,CommonJS规范 帮助Node形成了它的骨骼。只有茁壮的根,才能培养出茂盛的枝叶,并成长为参天大树。正是这 些底层的规范和实践,使得Node有序地发展着,摆脱掉过去JavaScript纷乱和被误解的局面,进 而进化成良性的生态系统。</p>
<h3 id="第3章-异步I-O"><a href="#第3章-异步I-O" class="headerlink" title="第3章　异步I/O"></a>第3章　异步I/O</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163de079a7e88a57?w=1193&amp;h=658&amp;f=jpeg&amp;s=118066" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddfd11745edcd?w=1383&amp;h=613&amp;f=jpeg&amp;s=152907" alt><br>本章介绍了异步I/O和另一些非I/O的异步方法。可以看出,事件循环是异步实现的核心,它 与浏览器中的执行模型基本保持了一致。而像古老的Rhino,尽管是较早就能在服务器端运行的 JavaScript运行时,但是执行模型并不像浏览器采用事件驱动,而是像其他语言一般采用同步I/O 作为主要模型,这造成它在性能上无所发挥。Node正是依靠构建了一套完善的高性能异步I/O框 架,打破了JavaScript在服务器端止步不前的局面。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/04/01/puling-node/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2019/03/15/u-not-know-javascript2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/15/u-not-know-javascript2/" itemprop="url">
                  《你不知道的javascript》中卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T17:10:00+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2019/03/15/u-not-know-javascript2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/15/u-not-know-javascript2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书《你不知道的javascript》中卷介绍了该系列的两个主题：“类型和语法”以及“异步与性能”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f4d3ede46a?w=1105&amp;h=870&amp;f=jpeg&amp;s=140823" alt><br>JavaScript 有 七 种 内 置 类 型: null 、 undefined 、 boolean 、 number 、 string 、 object 和 symbol ,可以使用 typeof 运算符来查看。</p>
<p>变量没有类型,但它们持有的值有类型。类型定义了值的行为特征。</p>
<p>很多开发人员将 undefined 和 undeclared 混 为 一 谈, 但 在 JavaScript 中 它 们 是 两 码 事。 undefined 是值的一种。 undeclared 则表示变量还没有被声明过。</p>
<p>遗憾的是, JavaScript 却将它们混为一谈, 在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined, 并 且 typeof 对 undefined 和 undeclared 变 量 都 返 回 “undefined” 。</p>
<p>然而,通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量,有时是个不错的办法。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f9fd654d30?w=1299&amp;h=398&amp;f=jpeg&amp;s=77055" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fbdebcded2?w=1300&amp;h=894&amp;f=jpeg&amp;s=195120" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fdca914292?w=1303&amp;h=706&amp;f=jpeg&amp;s=150852" alt></p>
<p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似,但是它们的 行为特征不同, 在将字符作为数组来处理时需要特别小心。 JavaScript 中的数字包括“整 数”和“浮点型”。</p>
<p>基本类型中定义了几个特殊的值。</p>
<p>null 类型只有一个值 null , undefined 类型也只有一个值 undefined 。 所有变量在赋值之 前默认值都是 undefined 。 void 运算符返回 undefined 。</p>
<p>数 字 类 型 有 几 个 特 殊 值, 包 括 NaN ( 意 指“not a number” , 更 确 切 地 说 是“invalid number” )、 +Infinity 、 -Infinity 和 -0 。</p>
<p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递, 而复合值(对象等) 通过引用复制来赋值 / 传递。 JavaScript 中的引用和其他语言中的引用 / 指针不同,它们不 能指向别的变量 / 引用,只能指向值。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c303afb22377?w=1450&amp;h=770&amp;f=jpeg&amp;s=128562" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c306f032cf04?w=1450&amp;h=682&amp;f=jpeg&amp;s=180566" alt></p>
<p>JavaScript 为基本数据类型值提供了封装对象,称为原生函数(如 String 、 Number 、 Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如: String#trim() 和 Array#concat(..) )。</p>
<p>对于简单标量基本类型值,比如 “abc” ,如果要访问它的 length 属性或 String.prototype 方法, JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30a226085fc?w=1499&amp;h=239&amp;f=jpeg&amp;s=43515" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30d238ec375?w=1499&amp;h=891&amp;f=jpeg&amp;s=213161" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30efc487344?w=1499&amp;h=887&amp;f=jpeg&amp;s=203319" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c310cc70fdcc?w=1499&amp;h=823&amp;f=jpeg&amp;s=164996" alt></p>
<p>本章介绍了 JavaScript 的数据类型之间的转换,即强制类型转换:包括显式和隐式。</p>
<p>强制类型转换常常为人诟病, 但实际上很多时候它们是非常有用的。 作为有使命感的 JavaScript 开发人员,我们有必要深入了解强制类型转换,这样就能取其精华,去其糟粕。</p>
<p>显式强制类型转换明确告诉我们哪里发生了类型转换, 有助于提高代码可读性和可维 护性。</p>
<p>隐式强制类型转换则没有那么明显,是其他操作的副作用。感觉上好像是显式强制类型转 换的反面,实际上隐式强制类型转换也有助于提高代码的可读性。</p>
<p>在处理强制类型转换的时候要十分小心,尤其是隐式强制类型转换。在编码的时候,要知 其然,还要知其所以然,并努力让代码清晰易读。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c313229058fc?w=1250&amp;h=857&amp;f=jpeg&amp;s=153667" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c315bee42707?w=1253&amp;h=870&amp;f=jpeg&amp;s=194344" alt><br>JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。 从长远来看, 这有 助于更深入地掌握这门语言。</p>
<p>语句和表达式在英语中都能找到类比——语句就像英语中的句子,而表达式就像短语。表 达式可以是简单独立的,否则可能会产生副作用。</p>
<p>JavaScript 语法规则之上是语义规则(也称作上下文)。例如, { } 在不同情况下的意思不 尽相同,可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。</p>
<p>JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的 组合方式)。只要熟练掌握了这些规则,就能对如何合理地运用它们作出自己的判断。</p>
<p>ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制, 它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略), 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。</p>
<p>JavaScript 中有很多错误类型, 分为两大类:早期错误(编译时错误, 无法被捕获)和运 行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误,程序有语法错误 则无法运行。</p>
<p>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组,它的抽象泄漏给我们 挖了不少坑。因此,尽量不要使用 arguments ,如果非用不可,也切勿同时使用 arguments 和其对应的命名参数。</p>
<p>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场,但也容易引起困惑, 特别是在和带标签的代码块混用时。总之,使用 finally 旨在让代码更加简洁易读,切忌 弄巧成拙。</p>
<p>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是,如果对其理解得不够透 彻,稍不注意就很容易出错。</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h3 id="异步：现在与将来"><a href="#异步：现在与将来" class="headerlink" title="异步：现在与将来"></a>异步：现在与将来</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c318a66b1032?w=1200&amp;h=619&amp;f=jpeg&amp;s=126139" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31aeeeaae13?w=1200&amp;h=698&amp;f=jpeg&amp;s=138515" alt><br>实际上, JavaScript 程序总是至少分为两个块:第一块 现在 运行;下一块 将来 运行, 以响 应某个事件。尽管程序是一块一块执行的,但是所有这些块共享对程序作用域和状态的访 问,所以对状态的修改都是在之前累积的修改之上进行的。</p>
<p>一旦有事件需要运行, 事件循环就会运行, 直到队列清空。 事件循环的每一轮称为一个 tick。 用户交互、IO 和定时器会向事件队列中加入事件。</p>
<p>任意时刻,一次只能从队列中处理一个事件。执行事件的时候,可能直接或间接地引发一 个或多个后续事件。</p>
<p>并发是指两个或多个事件链随时间发展交替执行,以至于从更高的层次来看,就像是同时 在运行(尽管在任意时刻只处理一个事件)。</p>
<p>通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调,比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块,以便其他“进程”插入进来。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31dc255b722?w=1200&amp;h=845&amp;f=jpeg&amp;s=169244" alt></p>
<p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟,对于异步编程领域的发展,回调已经不够用了。</p>
<p>第一,大脑对于事情的计划方式是线性的、阻塞的、单线程的语义,但是回调表达异步流 程的方式是非线性的、非顺序的,这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码,会导致坏 bug。</p>
<p>我们需要一种更同步、更顺序、更阻塞的的方式来表达异步,就像我们的大脑一样。</p>
<p>第二,也是更重要的一点,回调会受到控制反转的影响,因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。 这种控制转移导 致一系列麻烦的信任问题,比如回调被调用的次数是否会超出预期。</p>
<p>可以发明一些特定逻辑来解决这些信任问题,但是其难度高于应有的水平,可能会产生更 笨重、更难维护的代码,并且缺少足够的保护,其中的损害要直到你受到 bug 的影响才会 被发现。</p>
<p>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调,这一方案都应可 以复用,且没有重复代码的开销。</p>
<p>我们需要比回调更好的机制。到目前为止,回调提供了很好的服务,但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3210ed1135d?w=1559&amp;h=321&amp;f=jpeg&amp;s=81813" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c322b9dce156?w=1559&amp;h=712&amp;f=jpeg&amp;s=219007" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32579139ed3?w=1561&amp;h=715&amp;f=jpeg&amp;s=201171" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3279bb0a8d7?w=1506&amp;h=773&amp;f=jpeg&amp;s=236818" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3299cc4a0d4?w=1504&amp;h=330&amp;f=jpeg&amp;s=101344" alt></p>
<p>Promise 非常好,请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。</p>
<p>它们并没有摈弃回调,只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。</p>
<p>Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法,这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个 问题的一种更好的解决方案!</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32bc25ce357?w=1430&amp;h=893&amp;f=jpeg&amp;s=251348" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32dfa81cca0?w=1429&amp;h=875&amp;f=jpeg&amp;s=220277" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32feeacf0c8?w=1429&amp;h=330&amp;f=jpeg&amp;s=82989" alt><br>生成器是 ES6 的一个新的函数类型, 它并不像普通函数那样总是运行到结束。 取而代之 的是, 生成器可以在运行当中(完全保持其状态)暂停, 并且将来再从暂停的地方恢复 运行。</p>
<p>这种交替的暂停和恢复是合作性的而不是抢占式的,这意味着生成器具有独一无二的能力 来暂停自身,这是通过关键字 yield 实现的。不过,只有控制生成器的迭代器具有恢复生 成器的能力(通过 next(..) )。</p>
<p>yield / next(..) 这一对不只是一种控制机制,实际上也是一种双向消息传递机制。 yield .. 表 达式本质上是暂停下来等待某个值,接下来的 next(..) 调用会向被暂停的 yield 表达式传回 一个值(或者是隐式的 undefined )。</p>
<p>在异步控制流程方面,生成器的关键优点是:生成器内部的代码是以自然的同步 / 顺序方 式表达任务的一系列步骤。其技巧在于,我们把可能的异步隐藏在了关键字 yield 的后面, 把异步移动到控制生成器的迭代器的代码部分。</p>
<p>换句话说,生成器为异步代码保持了顺序、同步、阻塞的代码模式,这使得大脑可以更自 然地追踪代码,解决了基于回调的异步的两个关键缺陷之一。</p>
<h3 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c33279d14790?w=1150&amp;h=757&amp;f=jpeg&amp;s=152257" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c334668ebefc?w=1150&amp;h=273&amp;f=jpeg&amp;s=64116" alt></p>
<p>本部分的前四章都是基于这样一个前提:异步编码模式使我们能够编写更高效的代码,通 常能够带来非常大的改进。但是,异步特性只能让你走这么远,因为它本质上还是绑定在 一个单事件循环线程上。</p>
<p>因此,在这一章里,我们介绍了几种能够进一步提高性能的程序级别的机制。</p>
<p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件(即程序),使用异步事件在 线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程 中,以提高主 UI 线程的响应性。</p>
<p>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API, 以获得高性能的数据并行运算,比如在大数据集上的数字处理。</p>
<p>最后, asm.js 描述了 JavaScript 的一个很小的子集, 它避免了 JavaScript 难以优化的部分 (比如垃圾收集和强制类型转换),并且让 JavaScript 引擎识别并通过激进的优化运行这样 的代码。可以手工编写 asm.js, 但是会极端费力且容易出错,类似于手写汇编语言(这也 是其名字的由来)。实际上, asm.js 也是高度优化的程序语言交叉编译的一个很好的目标, 比如 Emscripten 把 C/C++ 转换成 JavaScript(<a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="noopener">https://github.com/kripken/emscripten/wiki</a>) 。</p>
<p>JavaScript 还有一些更加激进的思路已经进入非常早期的讨论, 尽管本章并没有明确包含 这些内容,比如近似的直接多线程功能(而不是藏在数据结构 API 后面)。不管这些最终 会不会实现,还是我们将只能看到更多的并行特性偷偷加入 JavaScript, 但确实可以预见, 未来 JavaScript 在程序级别将获得更加优化的性能。</p>
<h3 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c336f145c542?w=1486&amp;h=883&amp;f=jpeg&amp;s=206732" alt></p>
<p>对一段代码进行有效的性能测试,特别是与同样代码的另外一个选择对比来看看哪种方案 更快,需要认真注意细节。</p>
<p>与其打造你自己的统计有效的性能测试逻辑,不如直接使用 Benchmark.js 库,它已经为你 实现了这些。但是,编写测试要小心,因为我们很容易就会构造一个看似有效实际却有缺 陷的测试,即使是微小的差异也可能扭曲结果,使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件/ 设备的偏差, 这一点很重要。 jsPerf.com 是很好的网站,用于众包性能测试运行。</p>
<p>遗憾的是,很多常用的性能测试执迷于无关紧要的微观性能细节,比如 x++ 对比 ++x 。编 写好的测试意味着理解如何关注大局, 比如关键路径上的优化以及避免落入类似不同的 JavaScript 实现细节这样的陷阱中。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变 得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行,不需要任何额外资源。这意味着,对递归算法来说,引擎不再需要限制栈深度。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2019/02/13/u-not-know-javascript1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/13/u-not-know-javascript1/" itemprop="url">
                  《你不知道的javascript》上卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-13T07:10:09+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2019/02/13/u-not-know-javascript1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/13/u-not-know-javascript1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h4 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a99495f8829f7?w=1377&amp;h=872&amp;f=jpeg&amp;s=209079" alt></p>
<p>作用域是一套规则,用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对 变量进行赋值,那么就会使用 LHS 查询;如果目的是获取变量的值,就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 的赋值操作。 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。<br>JavaScript 引擎首先会在代码执行前对其进行编译,在这个过程中,像 var a = 2 这样的声 明会被分解成两个独立的步骤：</p>
<ol>
<li>首先, var a 在其作用域中声明新变量。这会在最开始的阶段,也就是代码执行前进行。</li>
<li>接下来, a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>
</ol>
<p>LHS 和 RHS 查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所 需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层 楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。</p>
<p>不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下),该变量使用 LHS 引用的目标作为标识符,或者抛 出 ReferenceError 异常(严格模式下)。</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a994edf51a32f?w=1105&amp;h=471&amp;f=jpeg&amp;s=50305" alt></p>
<p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的,从而能够预测在执行过程中如何对它 们进行查找。</p>
<p>JavaScript 中有两个机制可以“欺骗”词法作用域: eval(..) 和 with 。 前者可以对一段包 含一个或多个声明的“代码”字符串进行演算,并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用 当作 作用域来处理,将对象的属性当作作 用域中的标识符来处理,从而创建了一个新的词法作用域(同样是在运行时)。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都 将 导致代码运行变慢。 不要使用它们。</p>
<h4 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9954593cc366?w=1689&amp;h=828&amp;f=jpeg&amp;s=160928" alt></p>
<p>函数是 JavaScript 中最常见的作用域单元。本质上,声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来,这是有意为之的良好软件的设计原则。</p>
<p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域, 也可以属于某个代码块(通常指 { .. } 内部)。</p>
<p>从 ES3 开始, try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字( var 关键字的表亲), 用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量,并且将变量添加到这个块 中。</p>
<p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在,开 发者可以并且也应该根据需要选择使用何种作用域,创造可读、可维护的优良代码。</p>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995873202ea4?w=1651&amp;h=539&amp;f=jpeg&amp;s=98748" alt></p>
<p>我们习惯将 var a = 2; 看作一个声明,而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明,第一个是编译阶段的任务,而第二个则是执行阶段的任务。</p>
<p>这意味着无论作用域中的声明出现在什么地方,都将在代码本身被执行前 首先 进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端,这个过程被称为提升。</p>
<p>声明本身会被提升,而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<p>要注意避免重复声明,特别是当普通的 var 声明和函数声明混合在一起的时候,否则会引 起很多危险的问题!</p>
<h4 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995bb92570eb?w=1549&amp;h=731&amp;f=jpeg&amp;s=158866" alt></p>
<p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人 才能够到达那里。但实际上它只是一个标准,显然就是关于如何在函数作为值按需传递的 词法环境中书写代码的。</p>
<p>当函数可以记住并访问所在的词法作用域,即使函数是在当前词法作用域之外执行,这时 就产生了闭包。</p>
<p>如果没能认出闭包,也不了解它的工作原理,在使用它的过程中就很容易犯错,比如在循 环中。但同时闭包也是一个非常强大的工具,可以用多种形式来实现 模块 等模式。模块有两个主要特征:</p>
<p>(1)为创建内部作用域而调用了一个包装函数;<br>(2)包装函数的返回 值必须至少包括一个对内部函数的引用,这样就会创建涵盖整个包装函数内部作用域的闭 包。</p>
<p>现在我们会发现代码中到处都有闭包存在,并且我们能够识别闭包然后用它来做一些有用 的事!</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h4 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a996bcbf28e91" alt></p>
<p>如果要判断一个运行中函数的 this 绑定,就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li><p>由 new 调用?绑定到新创建的对象。</p>
</li>
<li><p>由 call 或者 apply (或者 bind )调用?绑定到指定的对象。</p>
</li>
<li><p>由上下文对象调用?绑定到那个上下文对象。</p>
</li>
<li><p>默认:在严格模式下绑定到 undefined ,否则绑定到全局对象。</p>
</li>
</ol>
<p>一定要注意,有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定,你可以使用一个 DMZ 对象,比如 ø = Object.create(null) ,以保护全局对象。ES6中的箭头函数并不会使用四条标准的绑定规则, 而是根据当前的词法作用域来决定 this ,具体来说,箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和 ES6 之前代码中的 self = this 机制一样。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85faf904cf73?w=1378&amp;h=708&amp;f=jpeg&amp;s=79898" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85fd6750a810?w=1260&amp;h=798&amp;f=jpeg&amp;s=138155" alt></p>
<p>JavaScript 中的对象有字面形式(比如 var a = { .. } )和构造形式(比如 var a = new Array(..) )。字面形式更常用,不过有时候构造形式可以提供更多选项。</p>
<p>许多人都以为“JavaScript 中万物都是对象”,这是错误的。对象是 6 个(或者是 7 个,取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型,不同子类型具有不同 的行为,比如内部标签 [object Array] 表示这是对象的子类型数组。</p>
<p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访 问属性时, 引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]] ), [[Get]] 操作会检查对象本身是否包含这个属性,如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。</p>
<p>属性的特性可以通过属性描述符来控制,比如 writable 和 configurable 。此外,可以使用 Object.preventExtensions(..) 、 Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。</p>
<p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外,属性可以是 可枚举或者不可枚举的,这决定了它们是否会出现在 for..in 循环中。</p>
<p>你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象, 等等)中的值, for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>
<h4 id="混合对象”类”"><a href="#混合对象”类”" class="headerlink" title="混合对象”类”"></a>混合对象”类”</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9977ad530352?w=1428&amp;h=862&amp;f=jpeg&amp;s=135448" alt></p>
<p>类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类 似的语法,但是和其他语言中的类完全不同。</p>
<p>类意味着复制。</p>
<p>传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类 中。</p>
<p>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果。</p>
<p>JavaScript 并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式(无论显式还是隐式)可以用来模拟类的复制行为,但是通常会产生丑陋并且脆 弱的语法,比如显式伪多态( OtherObj.methodName.call(this, …) ),这会让代码更加难 懂并且难以维护。</p>
<p>此外, 显式混入实际上无法完全模拟类的复制行为, 因为对象(和函数!别忘了函数也 是对象)只能复制引用, 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多 问题。</p>
<p>总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋下更多的隐患。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997b039a7ade?w=1458&amp;h=603&amp;f=jpeg&amp;s=159321" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997def15b21f?w=1458&amp;h=781&amp;f=jpeg&amp;s=178700" alt></p>
<p>如果要访问对象中并不存在的一个属性, [[Get]] 操作(参见第 3 章)就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链),在查找属性时会对它进行遍历。</p>
<p>所有普通对象都有内置的 Object.prototype ,指向原型链的顶端(比如说全局作用域),如 果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上,因此语言中所有的对象都可以使用它们。</p>
<p>关联两个对象最常用的方法是使用 new 关键词进行函数调用, 在调用的 章)中会创建一个关联其他对象的新对象。4个步骤(第2章)中会创建一个关联其他对象的新对象。</p>
<p>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”,尽管它们实际上和传统面向类语言中的 类构造函数 不一样。</p>
<p>JavaScript 是 中的机制有一个核心区别, 那就是不会进行复制, 对象之间是通过内部的</p>
<p>虽然这些 机制和传统面向类语言中的“类初始化”和“类继承”很相似, 但是  javascript 机制和传统面向对象类语言中的“类初始化”和“类继承”很相似但是 javascript 中的机制有一个核心区别，就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p>
<p>出于各种原因,以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无 法帮助你理解 JavaScript 的 真实 机制(不仅仅是限制我们的思维模式)。</p>
<p>相比之下,“委托”是一个更合适的术语,因为对象之间的关系不是 复制 而是委托。</p>
<h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a998194b182d8?w=1754&amp;h=763&amp;f=jpeg&amp;s=132903" alt></p>
<p>在软件架构中你可以 选择是否 使用类和继承设计模式。大多数开发者理所当然地认为类是 唯一(合适)的代码组织方式,但是本章中我们看到了另一种更少见但是更强大的设计模式: 行为委托 。</p>
<p>行为委托认为对象之间是兄弟关系, 互相委托, 而不是父类和子类的关系。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制。</p>
<p>当你只用对象来设计代码时,不仅可以让语法更加简洁,而且可以让代码结构更加清晰。</p>
<p>对象关联(对象之前互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2018/12/26/http-read/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/26/http-read/" itemprop="url">
                  《图解HTTP》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-26T16:18:09+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/12/26/http-read/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/12/26/http-read/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 作为一个前端，如果能够深刻理解 HTTP 通信，能够让我们在日常开发工作中快速定位问题。所以我十分建议大家去读一下《图解HTTP》和《HTTP权威指南》。权威指南讲解的十分详细，内容也十分的全面，但是这本书的厚度也让很多同学望而却步。推荐大家从 《图解HTTP》 这本书开始学习，这本书虽然没有权威指南详细，但涵盖了很多我们日常开发需要的知识点，理解他，能让我们的开发效率事半功倍。</p>
<p>《图解HTTP》这本书对互联网基盘—— HTTP 协议进行了全面系统的介绍。作者从 HTTP 发展史开始，严谨地剖析了 HTTP 协议的结构，列举很多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。通过书中大量生动形象的通信图例，我们能够更全面地理解 HTTP 通信过程中客户端与服务器之间的交互情况。在读这本书的过程中我收获颇多，并用思维导图的方式记录下来，方便自己后期温故。如果你刚好没有读过，可以当做度这本书的预习阅读，相信你也会有所收获（思维导图图片可能有点小，记得点开看）</p>
<h3 id="了解-HTTP-协议访问-Web"><a href="#了解-HTTP-协议访问-Web" class="headerlink" title="了解 HTTP 协议访问 Web"></a>了解 HTTP 协议访问 Web</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1a63ea9a2e0?w=1562&amp;h=857&amp;f=jpeg&amp;s=195547" alt></p>
<p>这一章介绍了 Web 及网络协议的基础，http 通讯被拆分成四层，应用层，传输层，网络层和链路层，每层只要考虑分派给自己的任务，不需要弄清整个协议链路的细节。应用层使我们肉眼能看见的，我们常用的 http 协议和 FTP 协议就处在这一层，往下就是传输层，TCP/IP 协议工作的地方（我们的IP是IP地址，和这里的IP 协议有做区分），再往下是网络层，传输层建立连接之后，网络层负责将数据包的传输（数据包是网络传输的最小单位）。最后是链路层，用来连接网络配件的部分，举个栗子就是我们常说的网卡啊，光纤啊。在一个完整的数据传输中，客户端会按照应用层，传输层，网络层，链路层的顺序进行进行处理，每一层都会加一个首部，服务器端在接收的时候按照链路层，网路层，传输层，应用层的顺序去移除首部。</p>
<p>我们常说的3次握手就是 TCP 协议采用的策略，为了传输方便，TCP 将大数据分割成以报文为单位的数据包，IP 协议负责把数据包发送出去。在发送的过程中常常需要经过多个路由器的中转，这个时候会运用 ARP 协议来查找下一个路由器的地址。</p>
<p>通常用户的习惯会去访问域名而不是IP地址，将域名解析成对应的 IP 就需要用到 DNS 协议域名解析的服务。</p>
<h3 id="简单的-HTTP-协议"><a href="#简单的-HTTP-协议" class="headerlink" title="简单的 HTTP 协议"></a>简单的 HTTP 协议</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1a97d7961d7" alt></p>
<p>日常开发中我们感知不到 http 协议的底层实现，我们所了解的 HTTP 协议总是由客户端发起，服务端接收。我们关注到的请求，常常是请求的URI，协议版本，头部信息，及内容实体，我们常使用的响应信息则包括了响应状态，响应内容。</p>
<p>我们常常会使用不通的 http 方法来执行不同的操作。我们常使用 GET 来获取资源，使用 POST 传输实体主题，使用 PUT 传输文件，使用 DELETE 删除文件，使用 OPTIONS 询问支持的方法（常常在跨域的场景中使用），使用TRACE 获取访问路径，使用 CONNECT 用隧道协议链接代理。</p>
<p>http 协议是一种无状态协议，不会去记录上一次访问状态，这使得当我们要做类似于登录这样的公能的时候，需要通过 cookie 来进行状态的管理。</p>
<h3 id="HTTP-报文内的-HTTP-信息"><a href="#HTTP-报文内的-HTTP-信息" class="headerlink" title="HTTP 报文内的 HTTP 信息"></a>HTTP 报文内的 HTTP 信息</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ae31d809e0?w=1480&amp;h=856&amp;f=jpeg&amp;s=177072" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b0372ea19f?w=1480&amp;h=382&amp;f=jpeg&amp;s=93168" alt><br>通常HTTP报文（用于HTTP协议交互的信息）的结构包括，请求行，状态行，首部字段等，从 HTTP 的报文中，我们可以获得很多信息。在 MIME 扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同的数据类型， 在 HTTP 报文中使用多部分对象时，需要在首部字段上加上 Content-type 。</p>
<p>通过设置首部字段，来达到获取部分内容范围请求（请求资源中断后，不需要重新开始请求),将传输内容编码的目的，来提高加载效率。</p>
<p>有的时候不同的场景需要我们获取不同的内容，就比如页面的中英文切换的功能，在HTTP请求中，我们通过设置 accept 类的请求头字段实现，也就是内容协商的方式，返回最合适的内容。协商方式分为，服务器驱动协商，客户端驱动协商，透明协商。</p>
<h3 id="返回结果的-HTTP-状态"><a href="#返回结果的-HTTP-状态" class="headerlink" title="返回结果的 HTTP 状态"></a>返回结果的 HTTP 状态</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b307e6623f?w=1466&amp;h=859&amp;f=jpeg&amp;s=245755" alt></p>
<p>在HTTP通讯中，通过转态码，告知客户端的请求状态。状态码大致可以被分为 5 大类，1xx 表示接受的请求正在处理，2xx 表示请求正常处理完毕，3xx 表示需要进行附加操作以完成请求，4xx 表示客户端无法处理请求，5xx 表示服务器处理出错。</p>
<p>在这5大类请求中，我们常用的十几种状态码，需要我们重点去掌握，详细介绍看👆的思维导图。</p>
<h3 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b578adf6cd" alt></p>
<p>通过使用虚拟机，可以实现单台主机多个域名的站点部署。在实际通讯中，我们常常使用，代理，网关，隧道协助请求转发，安全通信。</p>
<p>为了提高网站性能，我们会使用缓存方式来提高站点请求速率，通常是通过设置代理服务器缓存和客户端缓存来实现。需要注意的是，缓存都会设置一个过期时间，站点内容更新时，缓存内容也需要及时更新。</p>
<h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b89773bfc0?w=1339&amp;h=607&amp;f=jpeg&amp;s=114773" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1d9e9e58cfd?w=1340&amp;h=582&amp;f=jpeg&amp;s=121933" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1dbbe71bcc5?w=1342&amp;h=805&amp;f=jpeg&amp;s=146900" alt></p>
<p>在请求中，HTTP 报文由请求方法，URI，HTTP版本，HTTP 首部字段等部分构成。在响应中，HTTP 的报文有 HTTP 版本，状态码，HTTP首部字段3部分构成。首部信息尤为重要，我们可以通过首部字段的设置来传递请求信息，类比于缓存控制，报文创建时间，是否压缩编码，是否支持跨域等。</p>
<h3 id="确保-Web-安全的-HTTPS"><a href="#确保-Web-安全的-HTTPS" class="headerlink" title="确保 Web 安全的 HTTPS"></a>确保 Web 安全的 HTTPS</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ded196ed33?w=1757&amp;h=757&amp;f=jpeg&amp;s=199221" alt><br>HTTP 简单灵活的设置也造就了他的缺点。1. 通信使用明文，内容可能被窃听。2、不验证通讯方省份，因此有可能会遭遇伪装。3、无法证明报文的完整性，所有有可能被篡改。HTTPS 其实也不算是一个全新的协议，HTTPS =  HTTP + 加密 + 认证 + 完整性保护。HTTPS 完善了 HTTP 的相关缺点，在 HTTP 的部分通信接口采用 SSL 和 TLS 协议替代，使用了数字证书认证机构和其他相关机关颁发的公开秘钥证书</p>
<h3 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1e642add91e?w=1519&amp;h=580&amp;f=jpeg&amp;s=85904" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1e8931b3b8e?w=1522&amp;h=867&amp;f=jpeg&amp;s=310600" alt><br>HTTP 的认证方式通常是 BASIC认证（基本认证），DIGEST认证（摘要认证），SSL 客户端认证，FormBase 认证（基于表单认证）。BASIC 认证和 DIGEST 认证通过首部字段 Authorization 确认认证信息，SSL 借由 HTTPS 客户端证书完成认证方式。 表单认证则是依赖于 cookie 保存用户的登录状态。</p>
<h3 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1eacf6af00b?w=1547&amp;h=873&amp;f=jpeg&amp;s=231791" alt></p>
<p>SPDY 在TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，使用 SPDY 使得 HTTP 协议的功能得到了扩展，实现了多路复用流，赋予请求优先级，压缩 HTTP 首部，推送功能，服务器提醒功能。</p>
<p>使用 WebSocket 进行全双工通信，只要建立了链接，客户端和服务器都能都主动得向对方发送信息。和 HTTP 相比，减少了每次建立连接的开销，减少了通信首部信息。</p>
<p>HTTP/2.0 改善了使用 web 时的速度体验。</p>
<h3 id="构建-Web-内容的技术"><a href="#构建-Web-内容的技术" class="headerlink" title="构建 Web 内容的技术"></a>构建 Web 内容的技术</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ecb65228ef?w=1655&amp;h=720&amp;f=jpeg&amp;s=189926" alt></p>
<p>web 应用开发语言的三剑客，HTML，CSS，javascript 。书出版的有点久所以书中没有提到，现在火爆的 web 构建技术，Vue，React 等流行前端框架。XML，JSON 数据发布语言，其中 JSON 比较常用，日常开发都离不了他。</p>
<h3 id="web-的攻击技术"><a href="#web-的攻击技术" class="headerlink" title="web 的攻击技术"></a>web 的攻击技术</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ef858e8495?w=1679&amp;h=305&amp;f=jpeg&amp;s=74588" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1f2063461d3?w=1679&amp;h=764&amp;f=jpeg&amp;s=193638" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1f3ee6ca4a2?w=1679&amp;h=623&amp;f=jpeg&amp;s=188622" alt><br>在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由的变更、篡改，在HTTP请求报文中加载攻击代码，就能发起对 Web 应用的攻击。Web 应用的攻击模式主要是主动攻击和被动攻击。</p>
<p>常见的攻击方式有，跨站脚本攻击，SQL 注入攻击，HTTP 首部注入攻击。这些攻击造成的影响见👆思维导图。通常简单的 HTTP 协议本身不会存在安全性的问题，协议本身也不会成为攻击对象，黑客利用的常常是因为设计和设置上的缺陷，会话管理疏忽等引发的安全漏洞进行攻击。</p>
<h3 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h3><p>白霸天的博客</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://MemoryNoodles.github.io/blog/2018/07/13/efficiency-javascript/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="老李">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/lyp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李永平的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李永平的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/13/efficiency-javascript/" itemprop="url">
                  《高性能 javascript》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-13T19:33:01+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/07/13/efficiency-javascript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/13/efficiency-javascript/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本期我来给大家推荐的书是《高性能JavaScript》,在这本书中我们能够了解 javascript 开发过程中的性能瓶颈,如何提升各方面的性能，包括代码的加载、运行、DOM交互、页面生存周期等。同样我们今天还是用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="加载和执行"><a href="#加载和执行" class="headerlink" title="加载和执行"></a>加载和执行</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fdcc454e6ee1?w=1331&amp;h=666&amp;f=jpeg&amp;s=167715" alt><br>管理浏览器中的 JavaScript 代码是个棘手的问题,因为代码执行阻塞了其他浏览器处理过程,诸如用户 界面绘制。每次遇到<code>&lt;script&gt;</code>标签,页面必须停下来等待代码下载(如果是外部的)并执行,然后再继续处 理页面其他部分。但是,有几种方法可以减少 JavaScript 对性能的影响:</p>
<ol>
<li>将所有<code>&lt;script&gt;</code>标签放置在页面的底部,紧靠 body 关闭标签<code>&lt;/body&gt;</code>的上方。此法可以保证页面在脚本 运行之前完成解析。</li>
<li>将脚本成组打包。页面的<code>&lt;script&gt;</code>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</li>
</ol>
<p>有几种方法可以使用非阻塞方式下载 JavaScript:</p>
<ul>
<li>为<code>&lt;script&gt;</code>标签添加 defer 属性(只适用于 Internet Explorer 和 Firefox 3.5 以上版本)</li>
<li>动态创建<code>&lt;script&gt;</code>元素,用它下载并执行代码</li>
<li>用 XHR 对象下载代码,并注入到页面中</li>
</ul>
<p>通过使用上述策略,你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。</p>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fdcfe6225580?w=1406&amp;h=1141&amp;f=jpeg&amp;s=250469" alt></p>
<p>在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。它们有不同的性能考虑。</p>
<p>直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需 的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。嵌套对象成员会造成重大性能影响,尽量少用。</p>
<p>一个属性或方法在原形链中的位置越深,访问它的速度就越慢。一般来说,你可以通过这种方法提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变 量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。通过使用这些策略,你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>
<h3 id="DOM-编程"><a href="#DOM-编程" class="headerlink" title="DOM 编程"></a>DOM 编程</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fdd2b6dc3942?w=1401&amp;h=1776&amp;f=jpeg&amp;s=336802" alt><br>DOM 访问和操作是现代网页应用中很重要的一部分。但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛 时,都会被收取“过桥费”。为减少 DOM 编程中的性能损失,请牢记以下几点:</p>
<p>最小化 DOM 访问,在 JavaScript 端做尽可能多的事情。在反复访问的地方使用局部变量存放 DOM 引用.小心地处理 HTML 集合,因为他们表现出“存在性”,总是对底层文档重新查询。将集合的 length 属性缓 存到一个变量中,在迭代中使用这个变量。如果经常操作这个集合,可以将集合拷贝到数组中。</p>
<p>如果可能的话,使用速度更快的 API,诸如 querySelectorAll()和 firstElementChild。注意重绘和重排版;批量修改风格,离线操作 DOM 树,缓存并减少对布局信息的访问。动画中使用绝对坐标,使用拖放代理。使用事件托管技术最小化事件句柄数量。</p>
<h3 id="算法和流程控制"><a href="#算法和流程控制" class="headerlink" title="算法和流程控制"></a>算法和流程控制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fdd56a2ebbda?w=1387&amp;h=1352&amp;f=jpeg&amp;s=276447" alt><br>正如其他编程语言,代码的写法和算法选用影响 JavaScript 的运行时间。与其他编程语言不同的是, JavaScript 可用资源有限,所以优化技术更为重要。</p>
<p>for,while,do-while 循环的性能特性相似,谁也不比谁更快或更慢。除非你要迭代遍历一个属性未知的对象,否则不要使用 for-in 循环。改善循环性能的最好办法是减少每次迭代中的运算量,并减少循环迭代次数。</p>
<p>一般来说,switch 总是比 if-else 更快,但并不总是最好的解决方法。当判断条件较多时,查表法比 if-else 或者 switch 更快。</p>
<p>浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用;栈溢出错误导致其他代码也不能正常执行。如果你遇到一个栈溢出错误,将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</p>
<p>运行的代码总量越大,使用这些策略所带来的性能提升就越明显。</p>
<h3 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fdd820a10240?w=1409&amp;h=1707&amp;f=jpeg&amp;s=359339" alt><br>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍,但本章中的建议可帮助您避免常见缺陷。当连接数量巨大或尺寸巨大的字符串时,数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法。如果你不关心 IE7 和它的早期版本,数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之, 可避免(产生)不必要的中间字符串。</p>
<p>回溯既是正则表达式匹配功能基本的组成部分,又是正则表达式影响效率的常见原因。回溯失控发生在正则表达式本应很快发现匹配的地方,因为某些特殊的匹配字符串动作,导致运行缓慢 甚至浏览器崩溃。避免此问题的技术包括:使相邻字元互斥,避免嵌套量词对一个字符串的相同部分多次 匹配,通过重复利用前瞻操作的原子特性去除不必要的回溯。</p>
<p>提高正则表达式效率的各种技术手段,帮助正则表达式更快地找到匹配,以及在非匹配位置上花费更少 时间(见《更多提高正则表达式效率的方法》)。正则表达式并不总是完成工作的最佳工具,尤其当你只是搜索一个文本字符串时。</p>
<p>虽然有很多方法来修整一个字符串,使用两个简单的正则表达式(一个用于去除头部空格,另一个用于 去除尾部空格)提供了一个简洁、跨浏览器的方法,适用于不同内容和长度的字符串。从字符串末尾开始 循环查找第一个非空格字符,或者在一个混合应用中将此技术与正则表达式结合起来,提供了一个很好的 替代方案,它很少受到字符串整体长度的影响。</p>
<h3 id="快速响应用户界面"><a href="#快速响应用户界面" class="headerlink" title="快速响应用户界面"></a>快速响应用户界面</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dcd70084551?w=1446&amp;h=740&amp;f=jpeg&amp;s=159046" alt><br>JavaScript 和用户界面更新在同一个进程内运行,同一时刻只有其中一个可以运行。这意味着当 JavaScript 代码正在运行时,用户界面不能响应输入,反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行 太长时间,以免影响用户体验。最后,请牢记如下几点:</p>
<ol>
<li>JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟,从而对整体 用户体验产生负面影响。</li>
<li>JavaScript 运行期间,浏览器响应用户交互的行为存在差异。无论如何,JavaScript 长时间运行将导致用 户体验混乱和脱节。</li>
<li>定时器可用于安排代码推迟执行,它使得你可以将长运行脚本分解成一系列较小的任务。</li>
</ol>
<p>网页工人线程是新式浏览器才支持的特性,它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。网页应用程序越复杂,积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允 许影响用户体验的程度。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/1657fddbf1ad2b4f?w=1410&amp;h=1709&amp;f=jpeg&amp;s=393143" alt><br>高性能 Ajax 包括:知道你项目的具体需求,选择正确的数据格式和与之相配的传输技术。</p>
<p>作为数据格式,纯文本和 HTML 是高度限制的,但它们可节省客户端的 CPU 周期。XML 被广泛应用 普遍支持,但它非常冗长且解析缓慢。JSON 是轻量级的,解析迅速(作为本地代码而不是字符串),交 互性与 XML 相当。字符分隔的自定义格式非常轻量,在大量数据集解析时速度最快,但需要编写额外的 程序在服务器端构造格式,并在客户端解析。</p>
<p>当从页面域请求数据时,XHR 提供最完善的控制和灵活性,尽管它将所有传入数据视为一个字符串, 这有可能降低解析速度。另一方面,动态脚本标签插入技术允许跨域请求和本地运行 JavaScript 和 JSON, 虽然它的接口不够安全,而且不能读取信息头或响应报文代码。多部分 XHR 可减少请求的数量,可在一次响应中处理不同的文件类型,尽管它不能缓存收到的响应报文。当发送数据时,图像灯标是最简单和最 有效的方法。XHR 也可用 POST 方法发送大量数据。</p>
<p>除这些格式和传输技术之外,还有一些准则有助于进一步提高 Ajax 的速度:</p>
<ol>
<li>减少请求数量,可通过 JavaScript 和 CSS 文件打包,或者使用 MXHR。</li>
<li>缩短页面的加载时间,在页面其它内容加载之后,使用 Ajax 获取少量重要文件。</li>
<li>确保代码错误不要直接显示给用户,并在服务器端处理错误。</li>
<li>学会何时使用一个健壮的 Ajax 库,何时编写自己的底层 Ajax 代码。</li>
</ol>
<p>Ajax 是提升你网站潜在性能之最大的改进区域之一,因为很多网站大量使用异步请求,又因为它提供 了许多不相关问题的解决方案,这些问题诸如,需要加载太多资源。对 XHR 的创造性应用是如此的与众 不同,它不是呆滞不友好的界面,而是响应迅速且高效的代名词;它不会引起用户的憎恨,谁见了它都会 爱上它。</p>
<h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dd6b39a18cd?w=1436&amp;h=686&amp;f=jpeg&amp;s=145779" alt></p>
<p>JavaScript 提出了一些独特的性能挑战,关系到你组织代码的方法。网页应用变得越来越高级,包含的 JavaScript 代码越来越多,出现了一些模式和反模式。请牢记以下编程经验:</p>
<ol>
<li>通过避免使用 eval_r()和 Function()构造器避免二次评估。此外,给 setTimeout()和 setInterval()传递函数参 数而不是字符串参数。</li>
<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>
<li>避免重复进行相同工作。当需要检测浏览器时,使用延迟加载或条件预加载。</li>
<li>当执行数学远算时,考虑使用位操作,它直接在数字底层进行操作。</li>
<li>原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。</li>
</ol>
<h3 id="构建并部署高性能-javascript-应用"><a href="#构建并部署高性能-javascript-应用" class="headerlink" title="构建并部署高性能 javascript 应用"></a>构建并部署高性能 javascript 应用</h3><p>开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响,最重要的几个步骤如下:</p>
<ol>
<li>合并 JavaScript 文件,减少 HTTP 请求的数量</li>
<li>使用 YUI 压缩器紧凑处理 JavaScript 文件</li>
<li>以压缩形式提供 JavaScript 文件(gzip 编码)</li>
<li>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,通过向文件名附加时间戳解决缓存问题</li>
<li>使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓 存</li>
</ol>
<p>所有这些步骤应当自动完成,不论是使用公开的开发工具诸如 Apache Ant,还是使用自定义的开发工具 以实现特定需求。如果你使这些开发工具为你服务,你可以极大改善那些大量使用 JavaScript 代码的网页 应用或网站的性能。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>当网页或应用程序变慢时,分析网上传来的资源,分析脚本的运行性能,使你能够集中精力在那些需要 努力优化的地方。使用网络分析器找出加载脚本和其它页面资源的瓶颈所在,这有助于决定哪些脚本需要延迟加载,或者 进行进一步分析。传统的智慧告诉我们应尽量减少 HTTP 请求的数量,尽量延迟加载脚本以使页面渲染速度更快,向用户 提供更好的整体体验。使用性能分析器找出脚本运行时速度慢的部分,检查每个函数所花费的时间,以及函数被调用的次数, 通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。虽然花费时间和调用次数通常是数据中最有价值的点,还是应当仔细察看函数的调用过程,可能发现其 它优化方法。这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们,确保开发时 间用在解决问题的刀刃上。</p>
<h3 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h3><p>白霸天的博客</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/lyp.jpg" alt="老李">
          <p class="site-author-name" itemprop="name">老李</p>
          <p class="site-description motion-element" itemprop="description">前端,李永平,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老李</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
