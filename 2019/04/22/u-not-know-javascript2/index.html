<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="你不知道的javascript》中卷"><meta name="keywords" content="javascript,思维导图"><meta name="author" content="老李,undefined"><meta name="copyright" content="老李"><title>你不知道的javascript》中卷【李永平的博客】</title><link rel="stylesheet" href="./css/fan.css"><link rel="stylesheet" href="./css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="./favicon.ico"><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: './',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分-作用域和闭包"><span class="toc-number">2.</span> <span class="toc-text">第一部分 作用域和闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-number">3.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值"><span class="toc-number">4.</span> <span class="toc-text">值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原生函数"><span class="toc-number">5.</span> <span class="toc-text">原生函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">6.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-number">7.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分-this-和对象原型"><span class="toc-number">8.</span> <span class="toc-text">第二部分 this 和对象原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步：现在与将来"><span class="toc-number">9.</span> <span class="toc-text">异步：现在与将来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回调"><span class="toc-number">10.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">11.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器"><span class="toc-number">12.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序性能"><span class="toc-number">13.</span> <span class="toc-text">程序性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能测试与调优"><span class="toc-number">14.</span> <span class="toc-text">性能测试与调优</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/lyp.jpg"></div><div class="author-info-name">老李</div><div class="author-info-description">前端,李永平,博客</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/MemoryNoodles/blog" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:729804002@163.com" target="_blank">E-Mail<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="tencent://message/?uin=729804002&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="./archives"><span class="pull-top">日志</span><span class="pull-bottom">6</span></a><a class="author-info-articles-tags article-meta" href="./tags"><span class="pull-top">标签</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="./">李永平的博客</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">你不知道的javascript》中卷</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-04-22 | 更新于 2019-04-22</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="./tags/javascript/">javascript</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="./tags/思维导图/">思维导图</a></div></div></div><div class="main-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书《你不知道的javascript》中卷介绍了该系列的两个主题：“类型和语法”以及“异步与性能”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f4d3ede46a?w=1105&amp;h=870&amp;f=jpeg&amp;s=140823" alt><br>JavaScript 有 七 种 内 置 类 型: null 、 undefined 、 boolean 、 number 、 string 、 object 和 symbol ,可以使用 typeof 运算符来查看。</p>
<p>变量没有类型,但它们持有的值有类型。类型定义了值的行为特征。</p>
<p>很多开发人员将 undefined 和 undeclared 混 为 一 谈, 但 在 JavaScript 中 它 们 是 两 码 事。 undefined 是值的一种。 undeclared 则表示变量还没有被声明过。</p>
<p>遗憾的是, JavaScript 却将它们混为一谈, 在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined, 并 且 typeof 对 undefined 和 undeclared 变 量 都 返 回 “undefined” 。</p>
<p>然而,通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量,有时是个不错的办法。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f9fd654d30?w=1299&amp;h=398&amp;f=jpeg&amp;s=77055" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fbdebcded2?w=1300&amp;h=894&amp;f=jpeg&amp;s=195120" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fdca914292?w=1303&amp;h=706&amp;f=jpeg&amp;s=150852" alt></p>
<p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似,但是它们的 行为特征不同, 在将字符作为数组来处理时需要特别小心。 JavaScript 中的数字包括“整 数”和“浮点型”。</p>
<p>基本类型中定义了几个特殊的值。</p>
<p>null 类型只有一个值 null , undefined 类型也只有一个值 undefined 。 所有变量在赋值之 前默认值都是 undefined 。 void 运算符返回 undefined 。</p>
<p>数 字 类 型 有 几 个 特 殊 值, 包 括 NaN ( 意 指“not a number” , 更 确 切 地 说 是“invalid number” )、 +Infinity 、 -Infinity 和 -0 。</p>
<p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递, 而复合值(对象等) 通过引用复制来赋值 / 传递。 JavaScript 中的引用和其他语言中的引用 / 指针不同,它们不 能指向别的变量 / 引用,只能指向值。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c303afb22377?w=1450&amp;h=770&amp;f=jpeg&amp;s=128562" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c306f032cf04?w=1450&amp;h=682&amp;f=jpeg&amp;s=180566" alt></p>
<p>JavaScript 为基本数据类型值提供了封装对象,称为原生函数(如 String 、 Number 、 Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如: String#trim() 和 Array#concat(..) )。</p>
<p>对于简单标量基本类型值,比如 “abc” ,如果要访问它的 length 属性或 String.prototype 方法, JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30a226085fc?w=1499&amp;h=239&amp;f=jpeg&amp;s=43515" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30d238ec375?w=1499&amp;h=891&amp;f=jpeg&amp;s=213161" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30efc487344?w=1499&amp;h=887&amp;f=jpeg&amp;s=203319" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c310cc70fdcc?w=1499&amp;h=823&amp;f=jpeg&amp;s=164996" alt></p>
<p>本章介绍了 JavaScript 的数据类型之间的转换,即强制类型转换:包括显式和隐式。</p>
<p>强制类型转换常常为人诟病, 但实际上很多时候它们是非常有用的。 作为有使命感的 JavaScript 开发人员,我们有必要深入了解强制类型转换,这样就能取其精华,去其糟粕。</p>
<p>显式强制类型转换明确告诉我们哪里发生了类型转换, 有助于提高代码可读性和可维 护性。</p>
<p>隐式强制类型转换则没有那么明显,是其他操作的副作用。感觉上好像是显式强制类型转 换的反面,实际上隐式强制类型转换也有助于提高代码的可读性。</p>
<p>在处理强制类型转换的时候要十分小心,尤其是隐式强制类型转换。在编码的时候,要知 其然,还要知其所以然,并努力让代码清晰易读。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c313229058fc?w=1250&amp;h=857&amp;f=jpeg&amp;s=153667" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c315bee42707?w=1253&amp;h=870&amp;f=jpeg&amp;s=194344" alt><br>JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。 从长远来看, 这有 助于更深入地掌握这门语言。</p>
<p>语句和表达式在英语中都能找到类比——语句就像英语中的句子,而表达式就像短语。表 达式可以是简单独立的,否则可能会产生副作用。</p>
<p>JavaScript 语法规则之上是语义规则(也称作上下文)。例如, { } 在不同情况下的意思不 尽相同,可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。</p>
<p>JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的 组合方式)。只要熟练掌握了这些规则,就能对如何合理地运用它们作出自己的判断。</p>
<p>ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制, 它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略), 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。</p>
<p>JavaScript 中有很多错误类型, 分为两大类:早期错误(编译时错误, 无法被捕获)和运 行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误,程序有语法错误 则无法运行。</p>
<p>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组,它的抽象泄漏给我们 挖了不少坑。因此,尽量不要使用 arguments ,如果非用不可,也切勿同时使用 arguments 和其对应的命名参数。</p>
<p>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场,但也容易引起困惑, 特别是在和带标签的代码块混用时。总之,使用 finally 旨在让代码更加简洁易读,切忌 弄巧成拙。</p>
<p>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是,如果对其理解得不够透 彻,稍不注意就很容易出错。</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h3 id="异步：现在与将来"><a href="#异步：现在与将来" class="headerlink" title="异步：现在与将来"></a>异步：现在与将来</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c318a66b1032?w=1200&amp;h=619&amp;f=jpeg&amp;s=126139" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31aeeeaae13?w=1200&amp;h=698&amp;f=jpeg&amp;s=138515" alt><br>实际上, JavaScript 程序总是至少分为两个块:第一块 现在 运行;下一块 将来 运行, 以响 应某个事件。尽管程序是一块一块执行的,但是所有这些块共享对程序作用域和状态的访 问,所以对状态的修改都是在之前累积的修改之上进行的。</p>
<p>一旦有事件需要运行, 事件循环就会运行, 直到队列清空。 事件循环的每一轮称为一个 tick。 用户交互、IO 和定时器会向事件队列中加入事件。</p>
<p>任意时刻,一次只能从队列中处理一个事件。执行事件的时候,可能直接或间接地引发一 个或多个后续事件。</p>
<p>并发是指两个或多个事件链随时间发展交替执行,以至于从更高的层次来看,就像是同时 在运行(尽管在任意时刻只处理一个事件)。</p>
<p>通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调,比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块,以便其他“进程”插入进来。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31dc255b722?w=1200&amp;h=845&amp;f=jpeg&amp;s=169244" alt></p>
<p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟,对于异步编程领域的发展,回调已经不够用了。</p>
<p>第一,大脑对于事情的计划方式是线性的、阻塞的、单线程的语义,但是回调表达异步流 程的方式是非线性的、非顺序的,这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码,会导致坏 bug。</p>
<p>我们需要一种更同步、更顺序、更阻塞的的方式来表达异步,就像我们的大脑一样。</p>
<p>第二,也是更重要的一点,回调会受到控制反转的影响,因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。 这种控制转移导 致一系列麻烦的信任问题,比如回调被调用的次数是否会超出预期。</p>
<p>可以发明一些特定逻辑来解决这些信任问题,但是其难度高于应有的水平,可能会产生更 笨重、更难维护的代码,并且缺少足够的保护,其中的损害要直到你受到 bug 的影响才会 被发现。</p>
<p>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调,这一方案都应可 以复用,且没有重复代码的开销。</p>
<p>我们需要比回调更好的机制。到目前为止,回调提供了很好的服务,但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3210ed1135d?w=1559&amp;h=321&amp;f=jpeg&amp;s=81813" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c322b9dce156?w=1559&amp;h=712&amp;f=jpeg&amp;s=219007" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32579139ed3?w=1561&amp;h=715&amp;f=jpeg&amp;s=201171" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3279bb0a8d7?w=1506&amp;h=773&amp;f=jpeg&amp;s=236818" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3299cc4a0d4?w=1504&amp;h=330&amp;f=jpeg&amp;s=101344" alt></p>
<p>Promise 非常好,请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。</p>
<p>它们并没有摈弃回调,只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。</p>
<p>Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法,这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个 问题的一种更好的解决方案!</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32bc25ce357?w=1430&amp;h=893&amp;f=jpeg&amp;s=251348" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32dfa81cca0?w=1429&amp;h=875&amp;f=jpeg&amp;s=220277" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32feeacf0c8?w=1429&amp;h=330&amp;f=jpeg&amp;s=82989" alt><br>生成器是 ES6 的一个新的函数类型, 它并不像普通函数那样总是运行到结束。 取而代之 的是, 生成器可以在运行当中(完全保持其状态)暂停, 并且将来再从暂停的地方恢复 运行。</p>
<p>这种交替的暂停和恢复是合作性的而不是抢占式的,这意味着生成器具有独一无二的能力 来暂停自身,这是通过关键字 yield 实现的。不过,只有控制生成器的迭代器具有恢复生 成器的能力(通过 next(..) )。</p>
<p>yield / next(..) 这一对不只是一种控制机制,实际上也是一种双向消息传递机制。 yield .. 表 达式本质上是暂停下来等待某个值,接下来的 next(..) 调用会向被暂停的 yield 表达式传回 一个值(或者是隐式的 undefined )。</p>
<p>在异步控制流程方面,生成器的关键优点是:生成器内部的代码是以自然的同步 / 顺序方 式表达任务的一系列步骤。其技巧在于,我们把可能的异步隐藏在了关键字 yield 的后面, 把异步移动到控制生成器的迭代器的代码部分。</p>
<p>换句话说,生成器为异步代码保持了顺序、同步、阻塞的代码模式,这使得大脑可以更自 然地追踪代码,解决了基于回调的异步的两个关键缺陷之一。</p>
<h3 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c33279d14790?w=1150&amp;h=757&amp;f=jpeg&amp;s=152257" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c334668ebefc?w=1150&amp;h=273&amp;f=jpeg&amp;s=64116" alt></p>
<p>本部分的前四章都是基于这样一个前提:异步编码模式使我们能够编写更高效的代码,通 常能够带来非常大的改进。但是,异步特性只能让你走这么远,因为它本质上还是绑定在 一个单事件循环线程上。</p>
<p>因此,在这一章里,我们介绍了几种能够进一步提高性能的程序级别的机制。</p>
<p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件(即程序),使用异步事件在 线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程 中,以提高主 UI 线程的响应性。</p>
<p>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API, 以获得高性能的数据并行运算,比如在大数据集上的数字处理。</p>
<p>最后, asm.js 描述了 JavaScript 的一个很小的子集, 它避免了 JavaScript 难以优化的部分 (比如垃圾收集和强制类型转换),并且让 JavaScript 引擎识别并通过激进的优化运行这样 的代码。可以手工编写 asm.js, 但是会极端费力且容易出错,类似于手写汇编语言(这也 是其名字的由来)。实际上, asm.js 也是高度优化的程序语言交叉编译的一个很好的目标, 比如 Emscripten 把 C/C++ 转换成 JavaScript(<a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="noopener">https://github.com/kripken/emscripten/wiki</a>) 。</p>
<p>JavaScript 还有一些更加激进的思路已经进入非常早期的讨论, 尽管本章并没有明确包含 这些内容,比如近似的直接多线程功能(而不是藏在数据结构 API 后面)。不管这些最终 会不会实现,还是我们将只能看到更多的并行特性偷偷加入 JavaScript, 但确实可以预见, 未来 JavaScript 在程序级别将获得更加优化的性能。</p>
<h3 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c336f145c542?w=1486&amp;h=883&amp;f=jpeg&amp;s=206732" alt></p>
<p>对一段代码进行有效的性能测试,特别是与同样代码的另外一个选择对比来看看哪种方案 更快,需要认真注意细节。</p>
<p>与其打造你自己的统计有效的性能测试逻辑,不如直接使用 Benchmark.js 库,它已经为你 实现了这些。但是,编写测试要小心,因为我们很容易就会构造一个看似有效实际却有缺 陷的测试,即使是微小的差异也可能扭曲结果,使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件/ 设备的偏差, 这一点很重要。 jsPerf.com 是很好的网站,用于众包性能测试运行。</p>
<p>遗憾的是,很多常用的性能测试执迷于无关紧要的微观性能细节,比如 x++ 对比 ++x 。编 写好的测试意味着理解如何关注大局, 比如关键路径上的优化以及避免落入类似不同的 JavaScript 实现细节这样的陷阱中。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变 得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行,不需要任何额外资源。这意味着,对递归算法来说,引擎不再需要限制栈深度。</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">老李</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://MemoryNoodles.github.io/blog/2019/04/22/u-not-know-javascript2/">https://MemoryNoodles.github.io/blog/2019/04/22/u-not-know-javascript2/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://MemoryNoodles.github.io/blog">李永平的博客</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="./2019/04/22/http-read/"><i class="fas fa-angle-left">&nbsp;</i><span>图解HTTP》</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="./2019/04/22/u-not-know-javascript1/"><span>你不知道的javascript》上卷</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2018 ～ 2019 By 老李</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="./js/copy.js"></script><!--script(src=url)--></body></html>